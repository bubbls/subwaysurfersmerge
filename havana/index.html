<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Subway Surfers: Havana</title>
    <link rel="icon" href="img/FirstAvatar.png">
    <script src="4399.js"></script>
    <script>
        // Initial configuration
        window.config = {
            loader: "unity",
            debug: false,
            maxRatio: 16 / 9,
            minRatio: 9 / 16,
            title: 'Subway Surfers: Havana',
            unityVersion: '2019.2.0f1',
            unityWebglBuildUrl: 'Havana_4.json',
            fileSize: 35,
            cachedDecompressedFileSizes: {
                'Havana_4.asm.code.unityweb': 9057213,
                'Havana_4.asm.framework.unityweb': 89460,
                'Havana_4.asm.memory.unityweb': 1004462,
                'Havana_4.data.unityweb': 18352095, // Original size
                'Havana_4.wasm.code.unityweb': 7336893, // Original size
                'Havana_4.wasm.framework.unityweb': 93791,
            },
        };

        // Configuration from the JSON file you provided
        window.unityConfig = {
            "dataUrl": "Havana_4.data.unityweb",
            "wasmCodeUrl": "Havana_4.wasm.code.unityweb",
            // Include other URLs from the JSON if your master-loader.js needs them
        };

        // *** Merging Logic to Create Blob URLs ***

        /**
         * Fetches two split parts, merges them into a single Blob, and returns a Blob URL.
         * @param {string} fileUrlBase - The base URL of the file (e.g., 'Havana_4.data.unityweb').
         * @returns {Promise<string>} - The Blob URL of the merged file.
         */
        async function mergeSplitFile(fileUrlBase) {
            const part1Url = `${fileUrlBase}.part1`;
            const part2Url = `${fileUrlBase}.part2`;

            console.log(`Fetching and merging: ${fileUrlBase}`);

            const [response1, response2] = await Promise.all([
                fetch(part1Url),
                fetch(part2Url)
            ]);

            if (!response1.ok || !response2.ok) {
                // If fetching fails, we revert to the original URL to try the non-split version
                console.error(`Failed to fetch split parts for ${fileUrlBase}. Reverting to original URL.`);
                return fileUrlBase; 
            }

            const [part1Data, part2Data] = await Promise.all([
                response1.arrayBuffer(),
                response2.arrayBuffer()
            ]);

            const combinedBlob = new Blob([part1Data, part2Data], {
                type: 'application/octet-stream'
            });

            return URL.createObjectURL(combinedBlob);
        }

        // *** Pre-loading and Configuration Update ***

        // This function executes the merge and updates the configuration before the main loader runs.
        async function prepareGameAssets() {
            // Adjust the base path to match the <base href> tag and the unityWebglBuildUrl path
            const basePath = ''; 
            
            // 1. Merge the main data file
            const dataUrlBase = basePath + window.unityConfig.dataUrl;
            const mergedDataUrl = await mergeSplitFile(dataUrlBase);
            window.unityConfig.dataUrl = mergedDataUrl; // Update config with the Blob URL

            // 2. Merge the wasm code file
            const wasmCodeUrlBase = basePath + window.unityConfig.wasmCodeUrl;
            const mergedWasmCodeUrl = await mergeSplitFile(wasmCodeUrlBase);
            window.unityConfig.wasmCodeUrl = mergedWasmCodeUrl; // Update config with the Blob URL
            
            console.log('File merging complete. Starting Unity loader...');

            // The 'master-loader.js' must be included *after* this script updates the config
            // However, to keep your original structure, we'll use a flag or a delayed load 
            // for the master-loader. For this example, we'll assume the master-loader checks
            // for the presence of window.unityConfig.
            
            // In a real-world scenario, you would dynamically load master-loader.js here
            // after the merge is complete. Since your HTML loads it directly in the body,
            // we'll rely on a global configuration object.
            window.assetsPrepared = true; 
        }

        // Execute the preparation
        prepareGameAssets();

    </script>
</head>

<body>
    <script src="master-loader.js"></script>
</body>

</html>